import { Injectable } from "@nestjs/common";
import {
	ConnectedSocket,
	MessageBody,
	type OnGatewayConnection,
	type OnGatewayDisconnect,
	type OnGatewayInit,
	SubscribeMessage,
	WebSocketGateway,
	WebSocketServer,
} from "@nestjs/websockets";
import type { Server, Socket } from "socket.io";
import type { ChatService, MsgBody } from "./websockets.service";

/* without specifying the port, it will use the default app port set in main.ts */
@Injectable()
@WebSocketGateway({
	/**
	 * specify a namespace, which is a subpath of the main URL
	 * e.g. http://localhost:3000/chat
	 */
	namespace: "chat",
	cors: {
		origin: "*",
		/* the initial WebSocket handshake is an HTTP request (usually a GET request) */
		methods: ["GET", "POST"],
	},
})
export class ChatGateway
	implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect
{
	@WebSocketServer()
	io!: Server;

	constructor(private readonly websocketsService: ChatService) {}

	afterInit() {
		console.log("Chat Websockets initialized");
	}

	handleConnection(clientSocket: Socket, ...args: any[]) {
		const { sockets } = this.io.sockets;
		/**
		 * here client.id s generated by socket.io and is unique for each connection,
		 * ensuring that each client can be individually identified and managed.
		 */
		this.websocketsService.sentToRoom(
			{ message: `Client id: ${clientSocket.id} connected` },
			clientSocket
		);

		if (sockets) {
			console.debug(`Number of connected clients: ${sockets.size}`);
		}
	}

	handleDisconnect(clientSocket: Socket) {
		this.websocketsService.sentToRoom(
			{ message: `Client id: ${clientSocket.id} disconnected` },
			clientSocket
		);
	}

	/**
	 * listen to the `message` event emited by the client,
	 * and get the content from the body of the event.
	 */
	@SubscribeMessage("c2s")
	receiveMessage(
		@MessageBody() body: MsgBody,
		@ConnectedSocket() clientSocket: Socket
	) {
		return this.websocketsService.sentToRoom(body, clientSocket);
	}
}
